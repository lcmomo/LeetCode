/*
 * @lc app=leetcode.cn id=861 lang=javascript
 *
 * [861] 翻转矩阵后的得分
 */

 /**
  * 
  * 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

        移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

        在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

        返回尽可能高的分数。

        

        示例：

        输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
        输出：39
        解释：
        转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
        0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
        

        提示：

        1 <= A.length <= 20
        1 <= A[0].length <= 20
        A[i][j] 是 0 或 1
  */

  /**
   * 
   * 思路：根据题意，给定一个翻转方案，他们之间任意交换顺序，得到的结果保持不变，因此，先翻转所有的行，再翻转所有的列。
   * 为了得到最高的分数，矩阵的每一行的最左边的数都必须为 1。为了做到这一点，我们可以翻转那些最左边的数不为 11 的那些行，而其他的行则保持不动。
   * 当将每一行的最左边的数都变为 1 之后，就只能进行列翻转了。为了使得总得分最大，我们要让每个列中 11 的数目尽可能多。因此，我们扫描除了最左边的列以外的每一列，如果该列 0 的数目多于 1 的数目，就翻转该列，其他的列则保持不变。
   * 实际编写代码，无需修改原矩阵，可以计算每一列对总分数的贡献。
   *   对最左变得列，最优情况下，取值都为1，每个元素对分数的贡献都为2^(n-1),总贡献m* 2^(n-1).
   *    对第j列（j > 0, 此处规定最左列为第0列）而言，我们统计这一列0，1 的数量 ，令其中最大值为k，则k是列翻转后的1的数量，该列总贡献 k* 2^(n- j -1).需要注意的一点，统计0，1数量时，要考虑最初进行的行翻转。
   * 
   */

// @lc code=start
/**
 * @param {number[][]} A
 * @return {number}
 */
var matrixScore = function(A) {
    if (!A || !A.length) return 0;
    let m = A.length;
    let n = A[0].length;

    let res = m * ( 1  << (n - 1)); // 没行的首位为1的贡献

    for (let j = 1; j < n; j++) {
        let countOfOne = 0;
        for (let i = 0; i < m; i++) {
            if(A[i][0] === 1) {   // 如果每行第一个数为1， 不翻转，否则必定翻转
                countOfOne += A[i][j];
            } else {
                countOfOne += (1 - A[i][j]); // 如果这一行进行了行反转，则该元素的实际取值为 1 - A[i][j]
            }
        }
        let k = Math.max(countOfOne, m - countOfOne);
        res += k * (1 << (n - j -1));
    }
    return res;
};


// 时间复杂度: O(mn) m行n列
// 空间复杂度：O(1)
// let arr = [[0,0,1,1],[1,0,1,0],[1,1,0,0]];
// console.log(matrixScore(arr));

// @lc code=end

