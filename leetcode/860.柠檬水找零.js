/*
 * @lc app=leetcode.cn id=860 lang=javascript
 *
 * [860] 柠檬水找零
 */

 /**
  * 
    * @在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

    顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

    每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

    注意，一开始你手头没有任何零钱。

    如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

    示例 1：

    输入：[5,5,5,10,20]
    输出：true
    解释：
    前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
    第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
    第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
    由于所有客户都得到了正确的找零，所以我们输出 true。
    示例 2：

    输入：[5,5,10]
    输出：true
    示例 3：

    输入：[10,10]
    输出：false
    示例 4：

    输入：[5,5,10,10,20]
    输出：false
    解释：
    前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
    对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
    对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
    由于不是每位顾客都得到了正确的找零，所以答案是 false。
    

    提示：

    0 <= bills.length <= 10000
    bills[i] 不是 5 就是 10 或是 20 
  */

  /**
   * 
   *   思路：贪心法：
   *    一开始没有任何钞票，因此我们拥有的钞票面值只能是5，10， 20 三种
   *        5: 柠檬水价格5美元，直接收
   *        10: 如果手里没有5美元，无法找零
   *        20: 两种情况： 一张10和一张5， 3张5， 两种方式都没有，无法找零，都有，优先考虑1个10和一个5的。
   *  基于此： 可以维护两个变量，five， ten， 表示手中5美元和10美元的个数，从前往后，遍历数组
   * 
   */

// @lc code=start
/**
 * @param {number[]} bills
 * @return {boolean}
 */
var lemonadeChange = function(bills) {

    let five = 0;
    let ten = 0;

    for (let item of bills) {
        if (item === 5) {  //  5 直接收
            five += 1;
        } else if (item === 10) {  // 10   5为0 不能找零
            if (five === 0) {  
                return false;
            } else {
                five -= 1; //  找零5快
                ten += 1; // 收一张10
            }
        } else {  // 20的
            if (five > 0 && ten > 0) {
                ten -= 1;
                five -= 1;
            } else if (five >= 3) {
                five -= 3;
            } else {
                return false;
            }
        }
    }

    return true;

};

// 时间复杂度： O(N)
// 空间复杂度： O（1）
// let arr = [5,5,10,10,20];
// console.log(lemonadeChange(arr));
// @lc code=end

